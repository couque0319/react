
# 📘 React Hooks 개념 및 배경

## 🔍 React Hooks란?

React Hooks는 **함수형 컴포넌트**에서 상태(state) 관리와 생명주기(lifecycle) 기능을 사용할 수 있게 해주는 기능입니다.

> "Hook"이란 특정 위치에 원하는 함수가 실행되도록 **갈고리(hook)** 를 거는 것을 의미합니다.

---

## 🧱 등장 배경

### 🔸 React 컴포넌트 구조

- React 컴포넌트는 크게 두 가지:
  - 함수형 컴포넌트 (Functional Component)
  - 클래스형 컴포넌트 (Class Component)

- React 초기에는:
  - **간단한 구조**는 함수형 컴포넌트로
  - **상태(state)** 또는 **생명주기(lifecycle)** 가 필요하면 클래스형 컴포넌트 사용

### 🔸 클래스형 컴포넌트의 단점

- 코드 구성이 복잡하고 재사용성이 낮음
- 컴파일 단계에서 최적화가 어려움
- 최신 기술 적용이 제한적

➡️ 이를 보완하기 위해 **React v16.8에서 Hook이 도입됨**

---

## ✅ Hooks의 장점

| 장점 | 설명 |
|------|------|
| ✅ 상태 로직 단순화 | 함수형 컴포넌트에서도 상태 추가 가능. 로직이 간단하고 명확해짐 |
| ✅ 코드 재사용성 및 관심사 분리 | 컴포넌트 계층을 바꾸지 않고도 상태 로직 재사용 가능 |
| ✅ 사이드 이펙트 감소 | 생명주기 메서드 없이도 사이드 이펙트를 효율적으로 제어 가능 (`useEffect`) |

---

## 📏 Hooks 사용 규칙

1. **최상위에서만 Hook 호출**

   - 반복문, 조건문, 중첩 함수 내부에서 사용 ❌  
   - 항상 같은 순서로 호출되어야 함 → React가 Hook 상태를 정확히 기억함

2. **React 함수 내에서만 Hook 호출**

   - 호출 가능한 위치:
     - React 함수형 컴포넌트
     - 커스텀 Hook 내부

   - 일반 함수에서는 호출 ❌

---

## 🧪 `useState` Hook

### 📌 개념

- `useState`는 함수형 컴포넌트에서 **상태(state)** 를 선언하고 업데이트할 수 있게 해주는 기본 Hook입니다.
- 클래스형의 `this.state`, `this.setState`를 대체합니다.

---

### 🧾 기본 문법

```jsx
const [state, setState] = useState(initialValue);
```

| 요소           | 설명                             |
|----------------|----------------------------------|
| `state`        | 현재 상태 값                      |
| `setState`     | 상태를 변경하는 함수              |
| `initialValue` | 상태의 초기값                     |

---

### 🛠️ `useState` 활용 요약

| 목적               | 예시                                                              |
|--------------------|-------------------------------------------------------------------|
| 기본 사용          | `const [state, setState] = useState(초기값);`                     |
| 상태 변경          | `setState(새로운 값)`                                             |
| 객체 상태 관리     | `setState(prev => ({ ...prev, 변경값 }))`                         |
| 배열 상태 관리     | `setState([...배열, 새 요소])`                                    |
| 비동기 특성        | 상태 변경 직후에는 바로 반영되지 않을 수 있음                     |
| 함수형 업데이트    | `setState(prev => prev + 1)`                                      |
| 복잡한 상태 관리   | 상태 로직이 복잡하면 `useReducer` 사용 고려                       |

---

## 📌 커스텀 Hook 이름 규칙

- 모든 Hook의 이름은 **반드시 `use`로 시작**해야 합니다.
  - ✅ 올바른 예: `useState`, `useEffect`, `useFetch`, `useMyCustomHook`
  - ❌ 잘못된 예: `myHook`, `fetchDataHook` ← React가 Hook으로 인식하지 못함
- 커스텀 Hook을 만들 때도 `use`로 시작하는 이름을 지어야 React가 해당 함수를 **Hook으로 인식하고 동작 순서를 추적**할 수 있습니다.

---

---

## 🧠 setState 깊게 이해하기

`setState`는 React 컴포넌트의 상태를 업데이트하는 함수로, 다음과 같은 특징을 가집니다:

### ⚡ 비동기적 동작
- `setState`는 호출 즉시 상태를 변경하지 않고, React의 렌더링 사이클에 따라 **비동기적으로 처리**됩니다.
- 따라서 `setState` 직후 상태 값을 참조하면 **업데이트되지 않은 이전 값**을 얻을 수 있습니다.

### 📦 배치 처리 (Batching)
- React는 성능 최적화를 위해 여러 `setState` 호출을 **배치로 묶어 처리**합니다.
- 약 16ms 동안 발생한 상태 변경을 모아 **한 번에 리렌더링**하여 불필요한 렌더링을 방지하고 성능을 높입니다.

### 🔁 함수형 업데이트
- 이전 상태를 기반으로 새로운 상태를 설정할 때는 **함수형 업데이트**를 사용하는 것이 안전합니다.

```jsx
// 이전 상태를 참조하지 않는 경우
setState(newValue);

// 이전 상태를 참조하는 경우 (함수형 업데이트)
setState(prevState => prevState + 1);
```

---

## 🔄 동기, 비동기 / 블로킹, 논블로킹 개념

### ⏱ 동기(Synchronous) vs 비동기(Asynchronous)

| 구분 | 설명 | 예시 |
|------|------|------|
| 동기 | 작업이 순차적으로 실행됨. 하나 완료 전까지 다음 작업 대기 | 함수 호출, for문 |
| 비동기 | 기다리지 않고 다음 작업 수행 | setTimeout, fetch, Promise |

### 🚦 블로킹(Blocking) vs 논블로킹(Non-blocking)

| 구분 | 설명 | 예시 |
|------|------|------|
| 블로킹 | 작업 완료 전까지 프로그램 실행 중단 | 동기 파일 읽기 |
| 논블로킹 | 작업 완료 전에도 프로그램 계속 실행 | 이벤트 리스너, 콜백 |

---

## ⚙️ setState와 비동기 처리

- React의 `setState`는 **비동기 + 논블로킹** 방식입니다.
- 상태 업데이트를 요청해도 즉시 반영되지 않으며, **앱 실행은 중단되지 않습니다.**
- 여러 상태 업데이트를 모아 배치 처리하여 렌더링 성능을 최적화합니다.

---

## 🚀 성능 최적화 전략

### ✅ 배치 처리 활용
- 이벤트 핸들러 내 여러 `setState` 호출 → **자동 배치 처리**
- React 18부터는 **이벤트 핸들러 외부**에서도 자동 배치 지원

### ✅ 불필요한 리렌더링 방지
- `React.memo`, `useMemo`, `useCallback` 활용
- 객체/배열 상태 사용 시 **불필요한 참조 변경 피하기**

### ✅ 상태 구조화
- 관련 상태는 **하나의 객체로 묶어 관리**
- 복잡한 로직은 `useReducer`로 분리하여 유지보수 용이하게 구성

---
